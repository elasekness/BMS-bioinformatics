## Tutorial 2

**Objective:** To perform reference-based assemblies of SARS-CoV-2 genomes to determine whether cases from patients and staff at a facility are part of the same
transmission chain.

You will map reads to a reference assembly, generate consensus genomes, identify single nucleotide variants (SNVs),
and phylogenetically place genomes to determine whether the cases in question are epidemiologically related.
Additionally, we will employ and compare the results of different methods to generate our consensus genomes.
This includes using software that I have pre-installed on the VM as well as containerized versions of the same
software pulled from Docker. Finally, you will learn about GitHub and Docker for obtaining and installing bioinforamtics software.
<br>

## Some general information

Our read data are in fastq format. Fastq files contain the quality score for each nucleotide in the read and each read has four lines associated with it:

`>@SRR10971381.1 1 length=151`
<br>
`AGTCGATCAG`
<br>
`+`
<br>
`BBBCCCKKI`

> The read name, naming conventions may vary but names are always prefaced by '@'
<br>
> This is followed by the sequence line
<br>
> `+` a Line break
<br>
> Followed by quality scores for each nucleotide in ASCII format

<br>

Each base has an associated quality score, which indicates the reliability of that call.
Phred scores are equal to -10 log<sub>10</sub>P, where P is the error probability for the base in question.
Thus, a phred score of 10 is equal to an error probability of 0.01 (P=10<sup>â€“Q/10</sup>) or a 1 in 10 chance that the base call is incorrect.

Most NGS output is in fastq format.  We are working with short, paired-end reads (2x250 bp or 2x150 bp)
generated by Illumina sequencers (in this case a MiSeq or a NextSeq).
While Illumina reads are shorter than those from traditional Sanger sequencing, Illumina sequencing can produce millions to hundreds of millions of reads per sample.
<br>


## General workflow for producing a reference-based assembly

Reference-based assemblies rely on a reference genome on which to map the reads of a genomic library.
Reference assemblies allow the direct comparison of a genome of interest to an already-assembled genome for SNP and/or Indel detection.
Not all differences detected will be legitimate variation.  Miss-assembly (usually due to repetitive elements),
poor quality reads, low coverage, and contamination can all contribute to erroneous base calls.
Implementing additional filtering criteria to detect true variation is necessary,
such as only considering SNPs from an area of high coverage with a certain number of high-quality reads.
A general workflow for generating a reference-based assembly is given below:

<br>

**Quality control**

	* Generate some summary statistics with FastQC

**Adaptor removal (and primer removal) and quality trimming**

	- cutadapt
	- Trimmomatic
	- BBduk from BBtools
	- FastX-toolkit
	- TrimGalore
	- Seqyclean
	- And many more

**Read correction (optional, this is more important for long-read sequencing technologies such as Nanopore)**

	- Quake
	- BBnorm
	- SHRIMP
	- Quorum
	- Lighter
	- Fermi
	- Musket
	- And many, many more

**Read alignment or mapping to reference genome**

	- BWA
	- Bowtie
	- BBmap
	- STAR (for RNA-Seq)

**General statistics pertaining to reference assembly**

	- Samtools
	- Picard
	- BBtools
	- Quast

**SNP and INDEL calling**

	- Samtools/bcftools
	- GATK
	- iVAR

**Additional SNV filtering and annotation**

In our case, we'll also be generating consensus genomes with iVAR

<br>



